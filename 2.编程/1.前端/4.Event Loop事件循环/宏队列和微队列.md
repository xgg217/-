# 宏队列和微队列

## 宏队列和微队列 执行

+ 当执行栈清空时，JS 引擎首先会将微任务中的所有任务一次执行结束，如果没有微任务，则执行宏任务

## 宏队列 macrotask

+ `macrotask` 可称为 `task`

+ 每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）

+ 每一个 `task` 会从头到尾将这个任务执行完毕，不会执行其它

+ 浏览器为了能够使得JS内部 `task` 与 `DOM` 任务能够有序的执行，会在一个 `task` 执行结束后，在下一个 `task` 执行开始前，**对页面进行重新渲染** （task->渲染->task->...）

+ 场景：主代码块、计时器、AJAX请求、 DOM事件

## 微队列 microtask

+ `microtask` 称为 `jobs`

+ 可以理解是在当前 `task` 执行结束后立即执行的任务

+ 在当前task任务后，下一个task之前，**在渲染之前**

+ 所以它的响应速度相比 `setTimeout`（`setTimeout` 是 `task` ）会更快，因为无需等渲染

+ 也就是说，在某一个 `macrotask` 执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）

+ 场景： `Promise.then` 、 `MutationObserver` (可以用来实现 `microtask`，优先级小于 `Promise`， 一般是 `Promise` 不支持时才会这样做) 、 `process.nextTick`

## 补充说明

+ 在node环境下，`process.nextTick` 的优先级高于 `Promise`

+ 即在宏任务结束后会先执行微任务队列中的 `nextTickQueue` 部分，然后才会执行微任务中的 `Promise` 部分

## 线程解释

+ `macrotask`(宏队列) 中的事件都是放在一个事件队列中的，而这个队列由事件触发线程维护

+ `microtask` (微队列) 中的所有微任务都是添加到微任务队列（Job Queues）中，等待当前 `macrotask` 执行完毕后执行，而这个队列由JS引擎线程维护

（这点由自己理解+推测得出，因为它是在主线程下无缝执行的）

## 总结

+ 执行一个宏任务（栈中没有就从事件队列中获取）

+ 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中

+ 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）

+ 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染

+ 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）
