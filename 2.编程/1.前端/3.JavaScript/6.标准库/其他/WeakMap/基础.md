# 基础

## WeakMap 解决的问题

+ 赋值和搜索操作都是 O(n) 的时间复杂度( n 是键值对的个数)，因为这两个操作都需要遍历全部整个数组来进行匹配

+ 能会导致内存泄漏，因为数组会一直引用着每个键和值。这种引用使得垃圾回收算法不能回收处理他们，即使没有其他任何引用存在了

+ 相比之下，原生的 WeakMap 持有的是每个键对象的“弱引用”，这意味着在没有其他引用存在时垃圾回收能正确进行。原生 WeakMap 的结构是特殊且有效的，其用于映射的 key 只有在其没有被回收时才是有效的

+ 如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 `WeakMap`

  ```js
  // e1和e2是两个对象，我们通过arr数组对这两个对象添加一些文字说明。这就形成了arr对e1和e2的引用
  const e1 = document.getElementById('foo');
  const e2 = document.getElementById('bar');
  const arr = [
    [e1, 'foo 元素'],
    [e2, 'bar 元素'],
  ];

  // 一旦不再需要这两个对象，我们就必须手动删除这个引用，否则垃圾回收机制就不会释放e1和e2占用的内存
  // 不需要 e1 和 e2 的时候
  // 必须手动删除引用
  arr [0] = null;
  arr [1] = null;
  ```
