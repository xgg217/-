# 复合变换

## 示例1 位移两次

+ 想让一个物体位移两次

+ 已知

  + 初始点A(ax,ay,az, 1.0) `[ax,ay,az, 1.0]`
  + 第一次位移：沿x轴位移bx，沿y轴位移by
  + 第二次位移：沿x轴位移cx，沿y轴位移cy

+ 求：位移后的位置F(fx, fy, fz, fw)

  ![alt text](images/位移两次.png)
  ![alt text](images/位移两次矩阵计算.png)

+ 解

  + 步骤1: 设初次变换矩阵为bm（行主序）

    ```js
    // bm
    [
      1.0, 0.0, 0.0, bx,
      0.0, 1.0, 0.0, by,
      0.0, 0.0, 1.0, 0.0,
      0.0, 0.0, 0.0, 1.0,
    ]

    // 则第一次变换成的点f为
    f = bm * A
    fx = (1.0, 0.0, 0.0, bx) * (ax,ay,az, 1.0) = ax + bx
    fy = ( 0.0, 1.0, 0.0, by,) * (ax,ay,az, 1.0) = ay + by
    fz = (0.0, 0.0, 1.0, 0.0,) * (ax,ay,az, 1.0) = az
    fw = (0.0, 0.0, 0.0, 1.0,) * (ax,ay,az, 1.0) = 1.0
    ```

  + 步骤2:设第二次变换矩阵为cm(行主序)，则第二次变换后的点f为第二次变换矩阵乘以上一次变换后的点

    ```js
    // cm
    [
      1.0, 0.0, 0.0, cx,
      0.0, 1.0, 0.0, cy,
      0.0, 0.0, 1.0, 0.0,
      0.0, 0.0, 0.0, 1.0,
    ]

    // 则第一次变换成的点f为
    f = bm * A
    fx = (1.0, 0.0, 0.0, cx) * (fx,fy, fz, 1.0) = fz + cx
    fy = ( 0.0, 1.0, 0.0, cy,) * (fx,fy, fz, 1.0) = fy + cy
    fz = (0.0, 0.0, 1.0, 0.0,) * (fx,fy, fz, 1.0) = az
    fw = (0.0, 0.0, 0.0, 1.0,) * (fx,fy, fz, 1.0) = 1.0
    ```

  + 步骤3 通过两次的变换，最终的点F(cm * bm * A)

    ```js
    fx = ax + bx + cx
    fy = ay + by + cy
    fz = az
    fz = 1.0
    ```

+ code

  ```js
  // 第一次位移
  const [bx, by] = [0.4, 0.4];
  // 第二次位移
  const [cx, cy] = [0.3, 0.4];
  const bm = new Matrix4().set(
    1.0, 0, 0, bx,
    0, 1, 0, by,
    0, 0, 1, 0,
    0, 0, 1, 1,
  );

  const cm = new Matrix4().set(
    1.0, 0, 0, cx,
    0, 1, 0, cy,
    0, 0, 1, 0,
    0, 0, 1, 1,
  );

  const dm = cm.multiply(bm);
  gl.uniformMatrix4fv(u_Matrix, false, dm.elements);
  ```

## 示例2 先移动后旋转
