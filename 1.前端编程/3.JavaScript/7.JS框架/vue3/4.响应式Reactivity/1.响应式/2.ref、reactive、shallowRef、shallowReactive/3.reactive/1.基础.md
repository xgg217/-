# 基础

## 概述

+ reactive 通常将一个对象转为响应式对象

  ```html
  <template>
    <div>{{ state.count1 }}</div>
    <div>{{ state.nested.count2 }}</div>
  </template>

  <script setup>
  import { reactive } from 'vue'
  const state = reactive({
    count1: 0,
    nested: {
      count2: 0
    }
  })
  setTimeout(()=>{
    state.count1++
    state.nested.count2 += 2;
  },2000);
  </script>
  ```

## 最佳实践

+ 尽量使用 ref 来作为声明响应式数据的主要 API

## reactive局限性

1. 使用 reactvie 创建响应式数据的时候，值的类型是有限的

    + 只能是对象类型（object、array、map、set）
    + 不能够是简单值（string、number、boolean）


2. 不能够去替换响应式对象，否则会丢失响应式的追踪

    ```js
    let state = reactive({count : 0});

    // 下面的这个操作会让上面的对象引用不再被追踪，从而导致上面对象的响应式丢失
    state = reactive({count : 1})
    ```

3. 对解构操作不友好，当对一个 reactvie 响应式对象进行解构的时候，也会丢失响应式

    ```js
    let state = reactive({count : 0});
    // 当进行解构的时候，解构出来的是一个普通的值
    let { count } = state;
    count++; // 这里也就是单纯的值的改变，不会触发和响应式数据关联的操作

    // 另外还有函数传参的时候
    // 这里传递过去的也就是一个普通的值，没有响应式
    func(state.count)
    ```
